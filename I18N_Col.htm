<HEAD><CENTER><TITLE>I18N_Collate</TITLE>
</CENTER></HEAD>
<BODY><p><hr>

<H1> 
<A NAME="I18N::Collate_name_0">
NAME</A>
</H1>
I18N::Collate - compare 8-bit scalar data according to the current locale
<p><p><hr>

<H1> 
<A NAME="I18N::Collate_synopsis_0">
SYNOPSIS</A>
</H1>

<XMP>
    use I18N::Collate;
    setlocale(LC_COLLATE, 'locale-of-your-choice'); 
    $s1 = new I18N::Collate "scalar_data_1";
    $s2 = new I18N::Collate "scalar_data_2";

</XMP>
<p><p><hr>

<H1> 
<A NAME="I18N::Collate_description_0">
DESCRIPTION</A>
</H1>
This module provides you with objects that will collate 
according to your national character set, provided that the 
POSIX <EM>setlocale()</EM> function is supported on your system.
<p>You can compare <STRONG>$s1</STRONG> and <STRONG>$s2</STRONG> above with
<p>
<XMP>
    $s1 le $s2

</XMP>
<p>to extract the data itself, you'll need a dereference: 
<A HREF="perlvar.htm#perlvar__23">$$</A>
s1
<p>This uses POSIX::<EM>setlocale()</EM>. The basic collation conversion is done by
<EM>strxfrm()</EM> which terminates at NUL characters being a decent C routine.
<EM>collate_xfrm()</EM> handles embedded NUL characters gracefully.  Due to <CODE>cmp</CODE>
and overload magic, <CODE>lt</CODE>, <CODE>le</CODE>, <CODE>eq</CODE>, <CODE>ge</CODE>, and <CODE>gt</CODE> work also.  The
available locales depend on your operating system; try whether C<locale
-a&gt; shows them or man pages for ``locale'' or ``nlsinfo'' or
the direct approach <CODE>ls /usr/lib/nls/loc</CODE> or C<ls
/usr/lib/nls&gt;.  Not all the locales that your vendor supports
are necessarily installed: please consult your operating system's
documentation and possibly your local system administration.
<p>The locale names are probably something like
<CODE>``xx_XX.(ISO)?8859-N''</CODE> or <CODE>``xx_XX.(ISO)?8859N''</CODE>, for example
<CODE>``fr_CH.ISO8859-1''</CODE> is the Swiss (CH) variant of French (fr),
ISO Latin (8859) 1 (-1) which is the Western European character set.
<p>
</BODY>
</HTML>
