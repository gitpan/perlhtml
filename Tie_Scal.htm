<HEAD><CENTER><TITLE>Tie_Scalar</TITLE>
</CENTER></HEAD>
<BODY><p><hr>

<H1> 
<A NAME="Tie::Scalar_name_0">
NAME</A>
</H1>
Tie::Scalar, Tie::StdScalar - base class definitions for tied scalars
<p><p><hr>

<H1> 
<A NAME="Tie::Scalar_synopsis_0">
SYNOPSIS</A>
</H1>

<XMP>
    package NewScalar;
    require Tie::Scalar;
     
    @ISA = (Tie::Scalar);
     
    sub FETCH { ... }           # Provide a needed method
    sub TIESCALAR { ... }       # Overrides inherited method
         
     
    package NewStdScalar;
    require Tie::Scalar;
    
    @ISA = (Tie::StdScalar);
    
    # All methods provided by default, so define only what needs be overridden
    sub FETCH { ... }
    
    
    package main;
    
    tie $new_scalar, NewScalar;
    tie $new_std_scalar, NewStdScalar;

</XMP>
<p><p><hr>

<H1> 
<A NAME="Tie::Scalar_description_0">
DESCRIPTION</A>
</H1>
This module provides some skeletal methods for scalar-tying classes. See

<A HREF="perltie.htm">
the <EM>perltie</EM> manpage</A>
 for a list of the functions required in tying a scalar to a
package. The basic <STRONG>Tie::Scalar</STRONG> package provides a <CODE>new</CODE> method, as well
as methods 
<A HREF="Tie_Scal.htm#Tie::Scalar_tiescalar_0">TIESCALAR</A>
, 
<A HREF="Tie_Scal.htm#Tie::Scalar_fetch_0">FETCH</A>
 and 
<A HREF="Tie_Scal.htm#Tie::Scalar_store_0">STORE</A>
. The <STRONG>Tie::StdScalar</STRONG>
package provides all the methods specified in  
<A HREF="perltie.htm">
the <EM>perltie</EM> manpage</A>
. It inherits from
<STRONG>Tie::Scalar</STRONG> and causes scalars tied to it to behave exactly like the
built-in scalars, allowing for selective overloading of methods. The <CODE>new</CODE>
method is provided as a means of grandfathering, for classes that forget to
provide their own 
<A HREF="Tie_Scal.htm#Tie::Scalar_tiescalar_0">TIESCALAR</A>
 method.
<p>For developers wishing to write their own tied-scalar classes, the methods
are summarized below. The 
<A HREF="perltie.htm">
the <EM>perltie</EM> manpage</A>
 section not only documents these, but
has sample code as well:
<p>
<DL>
<DT>

<STRONG>

<A NAME="Tie::Scalar_tiescalar_0">
TIESCALAR classname, LIST</A>

</DT></STRONG>
<DD>
The method invoked by the command 
<A HREF="perlfunc.htm#perlfunc_tie_0">tie <STRONG>$scalar</STRONG>, classname</A>
. Associates a new
scalar instance with the specified class. <CODE>LIST</CODE> would represent additional
arguments (along the lines of <EM>AnyDBM_File</EM> and compatriots) needed to
complete the association.
<p>
<DT>

<STRONG>

<A NAME="Tie::Scalar_fetch_0">
FETCH this</A>

</DT></STRONG>
<DD>
Retrieve the value of the tied scalar referenced by <EM>this</EM>.
<p>
<DT>

<STRONG>

<A NAME="Tie::Scalar_store_0">
STORE this, value</A>

</DT></STRONG>
<DD>
Store data <EM>value</EM> in the tied scalar referenced by <EM>this</EM>.
<p>
<DT>

<STRONG>

<A NAME="Tie::Scalar_destroy_0">
DESTROY this</A>

</DT></STRONG>
<DD>
Free the storage associated with the tied scalar referenced by <EM>this</EM>.
This is rarely needed, as Perl manages its memory quite well. But the
option exists, should a class wish to perform specific actions upon the
destruction of an instance.
<p>
</DL>
<p><hr>

<H1> 
<A NAME="Tie::Scalar_more_0">
MORE INFORMATION</A>
</H1>
The 
<A HREF="perltie.htm">
the <EM>perltie</EM> manpage</A>
 section uses a good example of tying scalars by associating
process IDs with priority.
<p>
</BODY>
</HTML>
